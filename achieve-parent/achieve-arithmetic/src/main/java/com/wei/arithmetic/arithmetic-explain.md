### **一、基础算法排序查找算法**
 [csdn文章链接地址](https://blog.csdn.net/xingxing_tx/article/details/84752619)
 [git源码地址](https://github.com/xingxingtx/common-parent.git)

**1、选择排序(selectSort)**
 **1)原理:** 

```
  遍历元素找到一个最小（或最大）的元素，把它放在第一个位置，然后再在剩余元素中找到最小（或最大）的元素，把它放在第二个位置，依次下去，完成排序。
```
![selectionSort](D:\image\gif\selectionSort.gif)
 **2)直接选择排序步骤：**

```
 n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：
      ①初始状态：无序区为R[1..n]，有序区为空。
      ②第1趟排序
        　  在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序
        区和记录个数减少1个的新无序区。
    　　……
      ③第i趟排序
    　　    第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n](1≤i≤n-1)。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无
        序区的第1个记录R[i]交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。这样，n个记录的文件的直接
        选择排序可经过n-1趟直接选择排序得到有序结果。
```

 **3）算法分析：**
  （1）关键字比较次数

```
   无论文件初始状态如何，在第i趟排序中选出最小(或者最大值)关键字的记录，需做n-i次比较，因此，总的比较次数为： n(n-1)/2=o(n^2)
```

  （2）记录的移动次数

```
    当初始文件为正序时，移动次数为0
    无论文件初始状态如何，在第i趟排序中选出最小(或者最大值)关键字的记录，需做n-i次比较，因此，总的比较次数为： n(n-1)/2=o(n^2)
```

  （3）直接选择排序是一个就地排序
  （4）稳定性分析
      　直接选择排序是不稳定的
     【例】反例[2，2，1]  

  **4）Java实现**
```java
package com.wei.arithmetic.base;
import AbstractSort;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Arrays;
/**
 * @Describe 选择排序
 * @Author wei.peng
 * @Date 2021年05月05日
 */
public class SelectSort extends AbstractSort {

    private static Logger log = LoggerFactory.getLogger(SelectSort.class);

    /**
     * 选择排序
     *
     * @param array 需要排序的元素
     * @param order -1 降序 其余默认升序
     * 原理: 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕
     * 思路:
     * 1. 待排序数组: int[] array = { 5, 3, 6, 2, 10, 2, 1, 3, 5, 8, 10 , 16, 4};
     * 2. 第1趟排序，在待排序数据array[0]~array[n-1]中选出最小的数据，将它与array[0]交换；
     * 3. 第2趟排序，在待排序数据array[1]~array[n-1]中选出最小的数据，将它与array[1]交换；
     * 4. 以此类推，第i趟在待排序数据array[i-1]~array[n-1]中选出最小的数据，将它与array[i-1]交换，直到全部排序完成，需要n-1趟。
     */
    @Override
    public int[] sort(int[] array, int order) {
        if (array == null || array.length == 0) {
            return array;
        }
        //比较次数
        int count = 0;
        int length = array.length - 1;
        //需要比较的次数为array.length - 1次
        for (int i = 0; i < length; i++) {
            //假设每一趟第一个元素都是最小值或者最大值，记录当前索引
            int temp = i;
            //从剩余未排序序列中找到最小值下标
            for (int j = i + 1; j < array.length; j++) {
                count++;
                log.debug("比较次数为:{}", count);
                //降序排序
                if (order == -1) {
                    if (array[temp] < array[j]) {
                        temp = j;
                    }
                } else {//升序排序
                    if (array[temp] > array[j]) {
                        temp = j;
                    }
                }
            }
            //如果本身就是最小值或者最大值下标，则不需要交换
            if (temp != i) {
                log.debug("第{}趟, 交换位置数组下标:{}", i + 1, temp);
                swap(array, i, temp);
            }
            log.debug("第" + (i + 1) + "趟" + Arrays.toString(array));
        }
        return array;
    }
}

```

```java
package com.wei.arithmetic.test;
import SelectSort;

/**
 * @Describe
 * @Author wei.peng
 * @Date 2021年05月05日
 */
public class SortTest {
    public static void main(String[] args) {
        int[] arr = new int[] { 5, 3, 6, 2, 10, 2, 1, 3, 5, 8, 10 , 16, 4};
        //测试选择排序
        Sort sort = null;
        //选择排序
        sort = new SelectSort();
        sort.sort(arr, -1);
        //冒泡排序
        /*sort = new BubbleSort();
        sort.sort(arr, 1);*/
        //插入排序
       /* sort = new InsertSort();
        sort.sort(arr, 1);*/
    }
}
----------------------------------------------------------------------------------------
package com.wei.arithmetic.sort.abs;
import Sort;
/**
 * @Describe
 * @Author wei.peng
 * @Date 2021年05月06日
 */
public abstract class AbstractSort implements Sort {

    /**
     * 数组两个元素值交换
     * @param arr
     * @param i
     * @param j
     */
    protected  void swap(int[] arr, int i, int j) {
        if(arr == null || arr.length == 0 || i == j){return;}
        arr[i] = arr[i]^arr[j];
        arr[j] = arr[i]^arr[j];
        arr[i] = arr[i]^arr[j];
    }
}
----------------------------------------------------------------------------------------package com.wei.arithmetic.sort;
/**
 * @Describe
 * @Author wei.peng
 * @Date 2021年05月05日
 */
public interface Sort {
    /**
     * 排序给int数组排序
     * @param array 排序数组
     * @param order -1 降序，其余升序
     */
     public int[] sort(int[] array, int order);
}


```



**5）应用**

**2、冒泡排序(bubbleSort)**
 **1)原理：**

```
依次比较相邻的两个数,将小/大数学放在前面,大/小数数放在后面。
```
![bubbleSort](D:\image\gif\bubbleSort.gif)
 **2)比较步骤：**

```
 设数组的长度为N：
  (1)比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。
  (2)这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。
  (3)N=N-1，如果N不为0就重复前面二步，否则排序完成。
```

**3、插入排序(insertSort)**

**1)原理：**

```
   利用插入法对无序数组排序时，我们其实是将数组R划分成两个子区间R[1．．i-1]（已排好序的有序区）和R[i．．n]（当前未排序的部分，
   可称无序区）。插入排序的基本操作是将当前无序区的第1个记录R[i]插人到有序区R[1．．i-1]中适当的位置上，使R[1．．i]变为新的有序区。因为
这种方法每次使有序区增加1个记录，通常称增量法。
```
![insertSort](D:\image\gif\insertSort.gif)
  **2)步骤:**

```
1、以数组的某一位作为分隔位，比如index=1，假设左面的都是有序的
 2、将index位的数据拿出来，放到临时变量里，这时index位置就空出来了.
 3、从leftindex=index-1开始将左面的数据与当前index位的数据（即temp）进行比较，如果array[leftindex]>temp,
 则将array[leftindex]后移一位，即array[leftindex+1]=array[leftindex],此时leftindex就空出来了
 4、再用index-2(即leftindex=leftindex-1)位的数据和temp比，重复步骤3，
    直到找到<=temp的数据或者比到了最左面（说明temp最小），停止比较，将temp放在当前空的位置上
 5、index向后挪1，即index=index+1，temp=array[index],重复步骤2-4，直到index=array.length,排序结束，
    此时数组中的数据即为从小到大的顺序.
3)算法分析：
稳定 
空间复杂度O(1) 
时间复杂度O(n2) 
最差情况：反序，需要移动n*(n-1)/2个元素 
最好情况：正序，不需要移动元素
```

**4、快速排序(QuickSort)**
  **1)原理：**

```
   选择一个关键值作为基准值。比基准值小的都在左边序列（无序的），比基准值大的都在右边（无序的）。 一般选择序列的第一个元素
```
![quickSort](D:\image\gif\quickSort.gif)
  **2)步骤:**

     设要排序的数组是A[0]……A[N-1]
     1、设置两个变量I、J，排序开始的时候：I=0，J=N-1； 
     2、以第一个数组元素作为关键数据，赋值给X，即 X=A[0]； 
     3、从J开始向前搜索，即由后开始向前搜索（J=J-1），找到第一个小于X的值，让该值与X交换； 
     4、从I开始向后搜索，即由前开始向后搜索（I=I+1），找到第一个大于X的值，让该值与X交换； 
     5、重复第3、4步，直到 I=J；
  **3)算法分析：**
    稳定 
    空间复杂度O(1) 
    时间复杂度O(n2) 
    最差情况：反序，需要移动n*(n-1)/2个元素 
    最好情况：正序，不需要移动元素
**5、希尔排序(shellSort)**

**1)原理：**

```
    现将待排序的数组元素分成多个子序列，使得每个子序列的元素个数相对较少，然后对各个子序列分别进行直接插入排序，待整个待排序列“基本有序”后，最后在对所有元素进行一次直接插入排序。因此，我们要采用跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。希尔排序是对直接插入排序算法的优化和升级
```

 ![shellSort](D:\image\gif\shellSort.gif)

**2)步骤:**

```
1.先取一个正整数 d1(d1 < n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序
2.然后取 d2(d2 < d1)
重复上述分组和排序操作；直到取 di = 1(i >= 1) 位置，即所有记录成为一个组，
3.最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。
列如：我们有一个数组[ 13 14 94 33 82 25 59 94 65 23 45 27 73]如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列
```

 **3)算法分析：**

```
希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式移动，使得排序的效率提高。需要注意的是，增量序列的最后一个增量值必须等于1才行。另外，由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。
希尔排序最好时间复杂度和平均时间复杂度都是O(nlogn)，最坏时间复杂度为O(n^2)
```

 **4)应用：**

```

```

**6、堆排序**
**1)原理：**

```

```

**2)步骤:**

```

```

 **3)算法分析：**

```

```

 **4)应用：**

```

```

**7、计数排序**
**1)原理：**

```

```

**2)步骤:**

```

```

 **3)算法分析：**

```

```

 **4)应用：**

```

```

**8、桶排序**
**1)原理：**

```

```

**2)步骤:**

```

```

 **3)算法分析：**

```

```

 **4)应用：**

```

```

**9、桶基数排序**
**1)原理：**

```

```

**2)步骤:**

```

```

 **3)算法分析：**

```

```

 **4)应用：**

```

```

**10、二分查找**
**1)原理：**

```

```

**2)步骤:**

```

```

 **3)算法分析：**

```

```

 **4)应用：**

```

```

**11、布隆过滤器**
**1)原理：**

```

```

**2)步骤:**

```

```

 **3)算法分析：**

```

```

 **4)应用：**

```

```

**12 深度优先、广度优先**
**1)原理：**

```

```

**2)步骤:**

```

```

 **3)算法分析：**

```

```

 **4)应用：**

```

```

**13、贪心算法**
**1)原理：**

```

```

**2)步骤:**

```

```

 **3)算法分析：**

```

```

 **4)应用：**

```

```

**14、回溯算法**
**1)原理：**

```

```

**2)步骤:**

```

```

 **3)算法分析：**

```

```

 **4)应用：**

```

```

**15、剪枝算法**

**16、朴素贝叶**

**17、推荐算法**

**18、最小生成树算法**

**19、最短路径算法**

___

### ***二、提升类算法总结***
#### 1、搜索
* 1、BFS
* 2、DFS
* 3、强联通划分
* 4、割点、桥
* 5、双联通

#### 2、图论
* 1、最小生成树
* 2、二分图染色
* 3、二分图匹配
* 4、拓扑排序
* 5、最短路
* 6、Floyd
* 7、Dijkstra
* 8、SPFA
* 9、网络流&Dinic算法
* 10、最小费用流
* 11、上下限网络流
* 12、差分约束系统

#### 3、树
* 1、树的直径
* 2、树的重心
* 3、点分治
* 4、倍增LCA
* 5、虚树
* 6、DFS序
* 7、树链剖分

#### 4、数据结构
* 1、堆
* 2、单调队列、单调栈
* 3、ST表
* 4、Splay
* 5、CT
* 6、并查集
* 7、带权并查集
* 8、CDQ分治
* 9、线段树
* 10、树状数组
* 11、主席树
* 12、线段树合并

#### 5、字符串
* 1、KMP
* 2、拓展KMP
* 3、AC自动机
* 4、字符串hash
* 5、Manacher
* 6、后缀自动机
* 7、后缀数组
* 8、字典树

#### 6、动态规划
* 1、树形DP
* 2、状压DP
* 3、数位DP
* 4、斜率DP
* 5、区间DP
* 6、概率DP
* 7、插头DP

#### 7、数学
* 1、拓展欧几里得
* 2、乘法逆元
* 3、中国剩余定理
* 4、快速幂
* 5、矩阵快速幂
* 6、容斥原理
* 7、Polya
* 8、莫比乌斯反演
* 9、FFT、NTT
* 10、高斯消元
* 11、线性基

#### 8、博弈
*  1、Nim博弈

#### 9、几何
* 1、线段交、点积、差积
* 2、凸包

#### 10、其他
* 1、分块

* 2、莫队

* 3、KD树

  ___

### 三、加解密算法
* 1、RSA 
* 2、AES
* 3、ECDSA
* 4、SM2 
* 5、SM4
* 6.ECC