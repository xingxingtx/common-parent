### **一、基础算法 排序查找算法**
 [csdn文章链接地址](https://blog.csdn.net/xingxing_tx/article/details/84752619)
* **1、选择排序**
   **1)原理:** 

  ```
    遍历元素找到一个最小（或最大）的元素，把它放在第一个位置，然后再在剩余元素中找到最小（或最大）的元素，把它放在第二个位置，依次下去，完成排序。
  ```

   **2)直接选择排序步骤：**

  ```
   n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：
        ①初始状态：无序区为R[1..n]，有序区为空。
        ②第1趟排序
          　  在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序
          区和记录个数减少1个的新无序区。
      　　……
        ③第i趟排序
      　　    第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n](1≤i≤n-1)。该趟排序从当前无序区中选出关键字最小的记录R[k]，将它与无
          序区的第1个记录R[i]交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。这样，n个记录的文件的直接
          选择排序可经过n-1趟直接选择排序得到有序结果。
  ```

   **3）算法分析：**
    （1）关键字比较次数

  ```
     无论文件初始状态如何，在第i趟排序中选出最小(或者最大值)关键字的记录，需做n-i次比较，因此，总的比较次数为： n(n-1)/2=o(n^2)
  ```

    （2）记录的移动次数

  ```
      当初始文件为正序时，移动次数为0
      无论文件初始状态如何，在第i趟排序中选出最小(或者最大值)关键字的记录，需做n-i次比较，因此，总的比较次数为： n(n-1)/2=o(n^2)
  ```

  ​

        　当初始文件为正序时，移动次数为0
        　文件初态为反序时，每趟排序均要执行交换操作，总的移动次数取最大值3(n-1)。
        　直接选择排序的平均时间复杂度为O(n^2)。
    （3）直接选择排序是一个就地排序
    （4）稳定性分析
        　直接选择排序是不稳定的
       【例】反例[2，2，1]  

    **4）应用：**
        对应Java实现类：SelectSort.java

* **2、冒泡排序**
   1)原理：依次比较相邻的两个数,将小/大数学放在前面,大/小数数放在后面。
   2)比较步骤：
    设数组的长度为N：
    (1)比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。
    (2)这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。
    (3)N=N-1，如果N不为0就重复前面二步，否则排序完成。

* 3、插入排序
    1)原理：利用插入法对无序数组排序时，我们其实是将数组R划分成两个子区间R[1．．i-1]（已排好序的有序区）和R[i．．n]（当前未排序的部分，
    可称无序区）。插入排序的基本操作是将当前无序区的第1个记录R[i]插人到有序区R[1．．i-1]中适当的位置上，使R[1．．i]变为新的有序区。因为
    这种方法每次使有序区增加1个记录，通常称增量法。
    2)步骤:
       1、以数组的某一位作为分隔位，比如index=1，假设左面的都是有序的
       2、将index位的数据拿出来，放到临时变量里，这时index位置就空出来了.
       3、从leftindex=index-1开始将左面的数据与当前index位的数据（即temp）进行比较，如果array[leftindex]>temp,
       则将array[leftindex]后移一位，即array[leftindex+1]=array[leftindex],此时leftindex就空出来了
       4、再用index-2(即leftindex=leftindex-1)位的数据和temp比，重复步骤3，
          直到找到<=temp的数据或者比到了最左面（说明temp最小），停止比较，将temp放在当前空的位置上
       5、index向后挪1，即index=index+1，temp=array[index],重复步骤2-4，直到index=array.length,排序结束，
          此时数组中的数据即为从小到大的顺序.
      3)算法分析：
      稳定 
      空间复杂度O(1) 
      时间复杂度O(n2) 
      最差情况：反序，需要移动n*(n-1)/2个元素 
      最好情况：正序，不需要移动元素

* 4、快速排序
    1)原理：

  ​       选择一个关键值作为基准值。比基准值小的都在左边序列（无序的），比基准值大的都在右边（无序的）。
    一般选择序列的第一个元素
    2)步骤:

       设要排序的数组是A[0]……A[N-1]
       1、设置两个变量I、J，排序开始的时候：I=0，J=N-1； 
       2、以第一个数组元素作为关键数据，赋值给X，即 X=A[0]； 
       3、从J开始向前搜索，即由后开始向前搜索（J=J-1），找到第一个小于X的值，让该值与X交换； 
       4、从I开始向后搜索，即由前开始向后搜索（I=I+1），找到第一个大于X的值，让该值与X交换； 
       5、重复第3、4步，直到 I=J；
    3)算法分析：
      稳定 
      空间复杂度O(1) 
      时间复杂度O(n2) 
      最差情况：反序，需要移动n*(n-1)/2个元素 
      最好情况：正序，不需要移动元素

* 5、希尔排序

  原理：

  ```

  ```

  ​

* 6、堆排序

* 7、计数排序

* 8、桶排序

* 9、桶基数排序

* 10、二分查找

* 11、布隆过滤器

* 12 深度优先、广度优先

* 13、贪心算法

* 14、回溯算法

* 15、剪枝算法

* 16、朴素贝叶

* 17、推荐算法

* 18、最小生成树算法

* 19、最短路径算法

### 二、提升类算法总结
#### 1、搜索
* 1、BFS
* 2、DFS
* 3、强联通划分
* 4、割点、桥
* 5、双联通

#### 2、图论
* 1、最小生成树
* 2、二分图染色
* 3、二分图匹配
* 4、拓扑排序
* 5、最短路
* 6、Floyd
* 7、Dijkstra
* 8、SPFA
* 9、网络流&Dinic算法
* 10、最小费用流
* 11、上下限网络流
* 12、差分约束系统

#### 3、树
* 1、树的直径
* 2、树的重心
* 3、点分治
* 4、倍增LCA
* 5、虚树
* 6、DFS序
* 7、树链剖分

#### 4、数据结构
* 1、堆
* 2、单调队列、单调栈
* 3、ST表
* 4、Splay
* 5、CT
* 6、并查集
* 7、带权并查集
* 8、CDQ分治
* 9、线段树
* 10、树状数组
* 11、主席树
* 12、线段树合并

#### 5、字符串
* 1、KMP
* 2、拓展KMP
* 3、AC自动机
* 4、字符串hash
* 5、Manacher
* 6、后缀自动机
* 7、后缀数组
* 8、字典树

#### 6、动态规划
* 1、树形DP
* 2、状压DP
* 3、数位DP
* 4、斜率DP
* 5、区间DP
* 6、概率DP
* 7、插头DP

#### 7、数学
* 1、拓展欧几里得
* 2、乘法逆元
* 3、中国剩余定理
* 4、快速幂
* 5、矩阵快速幂
* 6、容斥原理
* 7、Polya
* 8、莫比乌斯反演
* 9、FFT、NTT
* 10、高斯消元
* 11、线性基

#### 8、博弈
*  1、Nim博弈

#### 9、几何
* 1、线段交、点积、差积
* 2、凸包

#### 10、其他
* 1、分块
* 2、莫队
* 3、KD树

### 三、加解密算法
* 1、RSA 
* 2、AES
* 3、ECDSA
* 4、SM2 
* 5、SM4